From 32f027b319d77d7ff6ee6ae3e6d3437c5b6e7490 Mon Sep 17 00:00:00 2001
From: Denis Benato <benato.denis96@gmail.com>
Date: Thu, 3 Apr 2025 15:41:07 +0200
Subject: [PATCH] platform/x86: asus-armoury: make xg mobile plug-and-play

Use a kthread to make xg mobile plug-and-play.
The thread presence and activation value is controlled via the auto_xgm option.

Signed-off-by: Denis Benato <benato.denis96@gmail.com>
---
 drivers/platform/x86/asus-armoury.c | 88 +++++++++++++++++++++++++++--
 1 file changed, 82 insertions(+), 6 deletions(-)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index 328d5e6d80ad59..232e45b880df7c 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -12,12 +12,14 @@
 #include <linux/acpi.h>
 #include <linux/bitfield.h>
 #include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/kmod.h>
 #include <linux/kobject.h>
+#include <linux/kthread.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/pci.h>
@@ -112,6 +114,8 @@ static struct asus_armoury_priv {
 	 * Mutex to prevent concurrent attempt to enable/disable the egpu.
 	 */
 	struct mutex egpu_mutex;
+
+	struct task_struct *egpu_kthread;
 } asus_armoury = {
 	.cpu_core_mutex = __MUTEX_INITIALIZER(asus_armoury.cpu_core_mutex),
 	.egpu_mutex = __MUTEX_INITIALIZER(asus_armoury.egpu_mutex)
@@ -130,6 +134,10 @@ struct asus_attr_group {
 	u32 wmi_devid;
 };
 
+static int auto_xgm = 0;
+module_param(auto_xgm, int, 1);
+MODULE_PARM_DESC(auto_xgm, "XGm auto-activation value: 0=off, otherwise a value supported by egpu_enable");
+
 static bool asus_wmi_is_present(u32 dev_id)
 {
 	u32 retval;
@@ -503,6 +511,16 @@ static ssize_t egpu_change_status(enum asus_armoury_egpu_action egpu_action)
 	return result;
 }
 
+/* Perform a PCI rescan: sometimes this is necessary after activating the eGPU */
+static void pci_rescan_after_egpu_change_status(void) {
+	struct pci_bus *b = NULL;
+
+	pci_lock_rescan_remove();
+	while ((b = pci_find_next_bus(b)) != NULL)
+		pci_rescan_bus(b);
+	pci_unlock_rescan_remove();
+}
+
 /* The ACPI call to enable the eGPU also disables the internal dGPU */
 static ssize_t egpu_enable_current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
 							const char *buf, size_t count)
@@ -510,7 +528,6 @@ static ssize_t egpu_enable_current_value_store(struct kobject *kobj, struct kobj
 	int err;
 	u32 requested;
 	enum asus_armoury_egpu_action act;
-	struct pci_bus *b = NULL;
 
 	err = kstrtou32(buf, 10, &requested);
 	if (err)
@@ -541,11 +558,7 @@ static ssize_t egpu_enable_current_value_store(struct kobject *kobj, struct kobj
 		return err;
 	}
 
-	/* Perform a PCI rescan: sometimes this is necessary */
-	pci_lock_rescan_remove();
-	while ((b = pci_find_next_bus(b)) != NULL)
-		pci_rescan_bus(b);
-	pci_unlock_rescan_remove();
+	pci_rescan_after_egpu_change_status();
 
 	sysfs_notify(kobj, NULL, attr->attr.name);
 
@@ -1285,6 +1298,51 @@ static void init_rog_tunables(void)
 	pr_err("Failed to allocate memory for tunables\n");
 }
 
+static int egpu_activation_poll_kthread(void *data) {
+	int err = 0;
+	u32 result;
+
+	while (!kthread_should_stop()) {
+		ssleep(5);
+
+		if (err) continue;
+
+		scoped_guard(mutex, &asus_armoury.egpu_mutex) {
+			err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_EGPU_CONNECTED, &result);
+			if (err) {
+				pr_warn("Failed to get eGPU connection status: %d\n", err);
+				continue;
+			}
+
+			/* eGPU interface is a stub: ignore the following */
+			if ((result & ASUS_WMI_DSTS_PRESENCE_BIT) == 0) continue;
+
+			/* eGPU is not connected: ignore the following */
+			if ((result & ~ASUS_WMI_DSTS_PRESENCE_BIT) == 0) continue;
+
+			err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_EGPU, &result);
+			if (err) {
+				pr_warn("Failed to get eGPU connection status: %d\n", err);
+				continue;
+			}
+
+			/* If the eGPU is connected, but it is not enabled proceed with the activation. */
+			if ((result & ~ASUS_WMI_DSTS_PRESENCE_BIT) == 0) {
+				err = egpu_change_status((enum asus_armoury_egpu_action)auto_xgm);
+				if (err < 0) {
+					pr_err("Failed to hotplug activate asus egpu: %d\n", err);
+				} else {
+					pci_rescan_after_egpu_change_status();
+				}
+			}
+		}
+	}
+
+	pr_info("asus egpu kthread threminated.\n");
+
+	return 0;
+}
+
 static int __init asus_fw_init(void)
 {
 	char *wmi_uid;
@@ -1316,12 +1374,30 @@ static int __init asus_fw_init(void)
 
 	init_rog_tunables();
 
+	if ((auto_xgm >= 1) && (auto_xgm <= 3)) {
+		pr_info("xgm auto-activation enabled with %d\n", auto_xgm);
+			if ((asus_wmi_is_present(ASUS_WMI_DEVID_EGPU)) && (asus_wmi_is_present(ASUS_WMI_DEVID_EGPU_CONNECTED))) {
+			asus_armoury.egpu_kthread = kthread_run(egpu_activation_poll_kthread, NULL, "asus_egpu_kthread");
+			if (IS_ERR(asus_armoury.egpu_kthread)) {
+				pr_err("Failed to create kernel thread: xg auto-activation is disabled\n");
+			}
+		}
+	} else {
+		pr_info("xgm auto-activation has been disabled\n");
+	}
+
 	/* Must always be last step to ensure data is available */
 	return asus_fw_attr_add();
 }
 
 static void __exit asus_fw_exit(void)
 {
+	if ((auto_xgm >= 1) && (auto_xgm <= 3))
+		if ((asus_armoury.egpu_kthread) && (!IS_ERR(asus_armoury.egpu_kthread)))
+			kthread_stop(asus_armoury.egpu_kthread);
+
+	mutex_lock(&asus_armoury.egpu_mutex);
+
 	sysfs_remove_file(&asus_armoury.fw_attr_kset->kobj, &pending_reboot.attr);
 	kset_unregister(asus_armoury.fw_attr_kset);
 	device_destroy(&firmware_attributes_class, MKDEV(0, 0));
